// Generated by CoffeeScript 1.9.2
var decaycurve, helpers, moment;

moment = require('timespanner');

helpers = require('odoql-exe/helpers');

decaycurve = function(x) {
  return (x - 1) * (x - 1);
};

module.exports = {
  unary: {
    time_coerce: function(exe, params) {
      return helpers.unary(exe, params, function(source) {
        return moment.spanner(source);
      });
    }
  },
  params: {
    time: function(exe, params) {
      return helpers.params(exe, params, function(params, source) {
        return moment(source, params);
      });
    },
    time_format: function(exe, params) {
      return helpers.params(exe, params, function(params, source) {
        return source.format(params);
      });
    },
    time_delta: function(exe, params) {
      return helpers.params(exe, params, function(params, source) {
        return source.spanner(params);
      });
    },
    time_nudge: function(exe, params) {
      var getdata, getlookback, getrange, getsource, getvalues;
      getlookback = exe.build(params.__p.lookback);
      getrange = exe.build(params.__p.range);
      getvalues = exe.build(params.__p.values);
      getdata = exe.build(params.__p.data);
      getsource = exe.build(params.__s);
      return function(cb) {
        return getlookback(function(err, lookback) {
          if (err != null) {
            return cb(err);
          }
          return getrange(function(err, range) {
            if (err != null) {
              return cb(err);
            }
            return getvalues(function(err, values) {
              if (err != null) {
                return cb(err);
              }
              return getdata(function(err, data) {
                if (err != null) {
                  return cb(err);
                }
                return getsource(function(err, source) {
                  var averages, d, deltas, fcpoint, i, j, k, l, lastobstime, len, len1, len2, len3, len4, len5, len6, lookbackuntil, m, n, o, obs, rangems, rangeuntil, v, x;
                  if (err != null) {
                    return cb(err);
                  }
                  if (data.length === 0) {
                    return cb(null, source);
                  }
                  lastobstime = data[0].time;
                  for (i = 0, len = data.length; i < len; i++) {
                    d = data[i];
                    if (lastobstime.isBefore(d.time)) {
                      lastobstime = d.time;
                    }
                  }
                  fcpoint = null;
                  for (j = 0, len1 = source.length; j < len1; j++) {
                    d = source[j];
                    if (d.time.isSame(lastobstime) || d.time.isAfter(lastobstime)) {
                      fcpoint = d;
                      break;
                    }
                  }
                  if (fcpoint == null) {
                    return cb(null, source);
                  }
                  lookbackuntil = lastobstime.clone().spanner(lookback);
                  obs = data.filter(function(d) {
                    if (d.time.isSame(lastobstime)) {
                      return true;
                    }
                    return d.time.isBefore(lastobstime) && d.time.isAfter(lookbackuntil);
                  });
                  if (obs.length === 0) {
                    return cb(null, source);
                  }
                  averages = {};
                  for (k = 0, len2 = values.length; k < len2; k++) {
                    v = values[k];
                    averages[v] = 0;
                    for (l = 0, len3 = obs.length; l < len3; l++) {
                      d = obs[l];
                      averages[v] += d.value;
                    }
                    averages[v] /= obs.length;
                  }
                  rangeuntil = lastobstime.clone().spanner(range);
                  rangems = rangeuntil.diff(lastobstime);
                  deltas = {};
                  for (m = 0, len4 = values.length; m < len4; m++) {
                    v = values[m];
                    deltas[v] = averages[v] - fcpoint[v];
                  }
                  for (n = 0, len5 = source.length; n < len5; n++) {
                    d = source[n];
                    if (d.time.isSame(lastobstime) || (d.time.isBefore(rangeuntil) && d.time.isAfter(lastobstime))) {
                      x = d.time.diff(lastobstime);
                      for (o = 0, len6 = values.length; o < len6; o++) {
                        v = values[o];
                        d[v] += deltas[v] * decaycurve(x / rangems);
                      }
                    }
                  }
                  return cb(null, source);
                });
              });
            });
          });
        });
      };
    },
    time_fill: function(exe, params) {
      return helpers.params(exe, params, function(params, source) {
        var merged, prop, ref, ref1, results, si, sj, value;
        if (source.length === 0) {
          return params;
        }
        if (params.length === 0) {
          return source;
        }
        results = [];
        si = 0;
        sj = 0;
        while (true) {
          while (si < source.length && sj < params.length && params[sj].time.isBefore(source[si].time)) {
            results.push(params[sj]);
            sj++;
          }
          while (si < source.length && sj < params.length && source[si].time.isBefore(params[sj].time)) {
            results.push(source[si]);
            si++;
          }
          if (si === source.length && sj === params.length) {
            break;
          }
          if (si === source.length) {
            while (sj < params.length) {
              results.push(params[sj]);
              sj++;
            }
            break;
          }
          if (sj === params.length) {
            while (si < source.length) {
              results.push(source[si]);
              si++;
            }
            break;
          }
          if (source[si].time.isSame(params[sj].time)) {
            merged = {};
            ref = source[si];
            for (prop in ref) {
              value = ref[prop];
              merged[prop] = value;
            }
            ref1 = params[sj];
            for (prop in ref1) {
              value = ref1[prop];
              if (merged[prop] == null) {
                merged[prop] = value;
              }
            }
            results.push(merged);
            si++;
            sj++;
            continue;
          }
          console.log("Shouldn't get here");
          break;
        }
        return results;
      });
    }
  }
};
