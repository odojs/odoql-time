// Generated by CoffeeScript 1.9.2
var decaycurve, helpers, moment;

moment = require('timespanner');

helpers = require('odoql-exe/helpers');

decaycurve = function(x) {
  return (x - 1) * (x - 1);
};

module.exports = {
  unary: {
    time_coerce: function(exe, params) {
      return helpers.unary(exe, params, function(source) {
        return moment.spanner(source);
      });
    }
  },
  params: {
    time: function(exe, params) {
      return helpers.params(exe, params, function(params, source) {
        return moment(source, params);
      });
    },
    time_utc: function(exe, params) {
      return helpers.params(exe, params, function(params, source) {
        return moment.utc(source, params);
      });
    },
    time_format: function(exe, params) {
      return helpers.params(exe, params, function(params, source) {
        return source.format(params);
      });
    },
    time_delta: function(exe, params) {
      return helpers.params(exe, params, function(params, source) {
        return source.spanner(params);
      });
    },
    time_nudge: function(exe, params) {
      var getdata, getkey, getlookback, getrange, getsource, gettarget;
      getlookback = exe.build(params.__p.lookback);
      getrange = exe.build(params.__p.range);
      getkey = exe.build(params.__p.key);
      gettarget = exe.build(params.__p.target);
      getdata = exe.build(params.__p.data);
      getsource = exe.build(params.__s);
      return function(cb) {
        return getlookback(function(err, lookback) {
          if (err != null) {
            return cb(err);
          }
          return getrange(function(err, range) {
            if (err != null) {
              return cb(err);
            }
            return getkey(function(err, key) {
              if (err != null) {
                return cb(err);
              }
              return gettarget(function(err, target) {
                if (err != null) {
                  return cb(err);
                }
                return getdata(function(err, data) {
                  if (err != null) {
                    return cb(err);
                  }
                  return getsource(function(err, source) {
                    var average, d, delta, fcpoint, i, j, k, l, lastobstime, len, len1, len2, len3, lookbackuntil, obs, rangems, rangeuntil, x;
                    if (err != null) {
                      return cb(err);
                    }
                    if (data.length === 0) {
                      return cb(null, source);
                    }
                    lastobstime = data[0].time;
                    for (i = 0, len = data.length; i < len; i++) {
                      d = data[i];
                      if (lastobstime.isBefore(d.time)) {
                        lastobstime = d.time;
                      }
                    }
                    fcpoint = null;
                    for (j = 0, len1 = source.length; j < len1; j++) {
                      d = source[j];
                      if (d.time.isSame(lastobstime) || d.time.isAfter(lastobstime)) {
                        fcpoint = d;
                        break;
                      }
                    }
                    if (fcpoint == null) {
                      return cb(null, source);
                    }
                    if (fcpoint[key] === 0) {
                      return cb(null, source);
                    }
                    lookbackuntil = lastobstime.clone().spanner(lookback);
                    obs = data.filter(function(d) {
                      if (d.time.isSame(lastobstime)) {
                        return true;
                      }
                      return d.time.isBefore(lastobstime) && d.time.isAfter(lookbackuntil);
                    });
                    if (obs.length === 0) {
                      return cb(null, source);
                    }
                    average = 0;
                    for (k = 0, len2 = obs.length; k < len2; k++) {
                      d = obs[k];
                      average += d[key];
                    }
                    average /= obs.length;
                    rangeuntil = lastobstime.clone().spanner(range);
                    rangems = rangeuntil.diff(lastobstime);
                    delta = average - fcpoint[key];
                    if (delta === 0) {
                      return cb(null, source);
                    }
                    delta /= fcpoint[key];
                    for (l = 0, len3 = source.length; l < len3; l++) {
                      d = source[l];
                      d[target] = 0;
                      if (d.time.isBefore(lastobstime)) {
                        d[target] = delta;
                      } else if (d.time.isSame(lastobstime) || (d.time.isBefore(rangeuntil) && d.time.isAfter(lastobstime))) {
                        x = d.time.diff(lastobstime);
                        d[target] = delta * decaycurve(x / rangems);
                      }
                    }
                    return cb(null, source);
                  });
                });
              });
            });
          });
        });
      };
    },
    time_fill: function(exe, params) {
      return helpers.params(exe, params, function(params, source) {
        var merged, prop, ref, ref1, results, si, sj, value;
        if (source.length === 0) {
          return params;
        }
        if (params.length === 0) {
          return source;
        }
        results = [];
        si = 0;
        sj = 0;
        while (true) {
          while (si < source.length && sj < params.length && params[sj].time.isBefore(source[si].time)) {
            results.push(params[sj]);
            sj++;
          }
          while (si < source.length && sj < params.length && source[si].time.isBefore(params[sj].time)) {
            results.push(source[si]);
            si++;
          }
          if (si === source.length && sj === params.length) {
            break;
          }
          if (si === source.length) {
            while (sj < params.length) {
              results.push(params[sj]);
              sj++;
            }
            break;
          }
          if (sj === params.length) {
            while (si < source.length) {
              results.push(source[si]);
              si++;
            }
            break;
          }
          if (source[si].time.isSame(params[sj].time)) {
            merged = {};
            ref = source[si];
            for (prop in ref) {
              value = ref[prop];
              merged[prop] = value;
            }
            ref1 = params[sj];
            for (prop in ref1) {
              value = ref1[prop];
              if (merged[prop] == null) {
                merged[prop] = value;
              }
            }
            results.push(merged);
            si++;
            sj++;
            continue;
          }
          console.log("Shouldn't get here");
          break;
        }
        return results;
      });
    }
  }
};
